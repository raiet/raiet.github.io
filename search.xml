<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>linux中hook成员函数</title>
      <link href="/%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD/hook_member_function/"/>
      <url>/%E6%8A%80%E6%9C%AF/%E8%BD%AC%E8%BD%BD/hook_member_function/</url>
      <content type="html"><![CDATA[<p>hook机制，无限强大，似乎是只有你想不到，没有他做不到的。之前一直有同学秀技术，可以破解某些需要注册的软件，觉得非常屌，看了这篇文章，似乎分分钟自己也能掳一个xx软件的破解版<br><a id="more"></a></p><p>原文地址：<a href="https://blog.keyidentity.com/2017/07/25/pwnadventure3-hooking-shared-library" target="_blank" rel="noopener">https://blog.keyidentity.com/2017/07/25/pwnadventure3-hooking-shared-library/</a></p><p>With our blog post about binary patching, we saw how to edit the client binary to modify a function in our advantage. The change was minor, i.e. a single line in assembly. If we want to modify the function to add more complex logic and thus more assembly code, we will need to use code cave in order to avoid overwriting essential instructions for the game to execute properly.</p><p>The code cave technique consist of finding an area in the binary that is not used and add our assembly instruction in it. Then, in the function we want to modify, we overwrite one instruction to jump in our code cave. Our code cave should save the registers and flags and restored them at the end of it, as well as re-aligning the stack. Finally, we should also add in our code cave the overwritten instruction (used for the the jump) and jump back in the initial function.</p><p>This procedure is often used by malware developer to hide malicious code into benign applications. The problem with this solution is that it is easy the break the application, and also, it requires you to write your changes in assembly.</p><p>An easier solution would be to hook the library used by the client in order to “hijack” the execution flow and run custom code. With this solution, you write a new library in C/C++ and use LD_PRELOAD (in Linux) to load your new library before all others. This post will give you an example of how to use LD_PRELOAD in order to modify the logic of the game and be able to teleport wherever you want at any time and change your movement speed and jump height on the fly.</p><p>Like with our packet injection proxy, we want to decide when to activate the hack. Therefore, we will hook the chat function so that whenever we send a specific string in the chat, it activates the appropriate “hack”. Chat is a great target since we can trigger it whenever we want, and send custom strings, which allow us a activate a wide range hack.</p><p>In this example, I will use Hopper to identify the chat function.</p><p>The function to hook is <code>Player::Chat()</code>. So in our new library, we will write the following code (hook.cc):<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// #define _GNU_SOURCE</span><br><span class="line"></span><br><span class="line">#include &lt;dlfcn.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">class Player &#123;</span><br><span class="line"> </span><br><span class="line">    public:</span><br><span class="line">        void Chat(const char *text);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">typedef void (*orig_chat_f_type)(Player *, const char *);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Player::Chat(const char *text)</span><br><span class="line">&#123;</span><br><span class="line">    std::string str(text);</span><br><span class="line">    std::cout &lt;&lt; &quot;Chat: &quot; &lt;&lt; str &lt;&lt; &quot;\n&quot;;</span><br><span class="line"></span><br><span class="line">    // Call orignal Player::Chat() function</span><br><span class="line">    orig_chat_f_type orig;</span><br><span class="line">    orig = (orig_chat_f_type) dlsym(RTLD_NEXT, &quot;_ZN6Player4ChatEPKc&quot;);</span><br><span class="line">    orig(this, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>In this example, we want to make sure that we hooked the right function. Therefore, we simply outputted the content of the chat for debug purposes. Since <code>Player::chat</code> is a member function of a class, we first need to define the class itself (i.e. Player) and declare the new function chat within. Once the function declared, we simply defined it. Thanks to the debug information from the libGameLogic.so, we know that the function name as well at the arguments and return types (i.e. it takes as argument one pointer to a Player object and one pointer to a char array, and return void).</p><p>We want the function chat to still operate as initially, so we want to re-route the execution flow back to the original Chat function. For this, we use dlsym to find the original Chat function address in the shared libraries and call it from the new Chat function. For this, we first need to define the variable that will receive the pointer to the original chat function. Then we use the mangled name to find the function with dlsym. Finally, we forward the parameters when calling the function.</p><p>Once the new C++ code written, we can compile our new shared library:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -shared -fPIC -o hook.so hook.cc</span><br></pre></td></tr></table></figure></p><p>Once done, we need to run the client with LD_PRELOAD so that we can load our new library before libGameLogic.so.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LD_PRELOAD=`pwd`/hook.so ./PwnAdventure3-Linux-Shipping</span><br></pre></td></tr></table></figure></p><p>The binary <code>PwnAdventure3-Linux-Shipping</code> is the actual executable for the game. The binary is located here:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PwnAdventure3_data/PwnAdventure3/PwnAdventure3/Binaries/Linux/PwnAdventure3-Linux-Shipping</span><br></pre></td></tr></table></figure></p><p>Now, we just need to join the game with any character and type anything in the chat dialog box (press enter) and you should see the text in the console where you executed the client.</p><h1 id="Teleport"><a href="#Teleport" class="headerlink" title="Teleport"></a>Teleport</h1><p>Now the we have successfully hijacked the chat function, we want to hack the game. For instance, teleporting wherever we want. We could develop a new function that will take care of changing our X, Y, Z position and update the server with our new location, but let’s check first if there is no function already available for that.</p><p>After spending some time looking for specific functions that contains words related to teleporting, I ended up with a very interesting function: <code>Player::PerformTeleport</code>. We can see in that function at an offset of 0x15843A a call to Actor::SetPosition(Vector3 const&amp;). This function take as argument a Vector3 variable (an array of 3 floats) that contains the coordinate to set the new position of an Actor (including our player).</p><p>Let’s try to call that function with arbitrary coordinate. Vector3 is a variable that contains 3 floats, for the 3 coordinate X, Y and Z:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struct Vector3 &#123; float x; float y; float z; &#125;;</span><br></pre></td></tr></table></figure></p><p>Let’s take a position close to Michael Angelo for instance:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Vector3 pos;</span><br><span class="line">pos.x = 260255.0;</span><br><span class="line">pos.y = -249336.0;</span><br><span class="line">pos.z = 1476.0;</span><br></pre></td></tr></table></figure></p><p>We will then use again dlsym to find the address of the function original function in the library:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typedef void (*orig_pos_f_type)(Player *, const Vector3 *);</span><br><span class="line">orig_pos_f_type orig;</span><br><span class="line">orig = (orig_pos_f_type) dlsym(RTLD_NEXT, &quot;_ZN5Actor11SetPositionERK7Vector3&quot;);</span><br></pre></td></tr></table></figure></p><p>Same as we’ve done before, we want to execute the function <code>Actor::SetPosition()</code> whenever we send a specific string in the chat, e.g. “Michael”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">void Player::Chat(const char *text)</span><br><span class="line">&#123;</span><br><span class="line">    std::string str(text);</span><br><span class="line"></span><br><span class="line">    if (str.compare(&quot;Michael&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        orig(this, &amp;p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call orignal Player::Chat() function</span><br><span class="line">    orig_chat_f_type orig;</span><br><span class="line">    orig = (orig_chat_f_type) dlsym(RTLD_NEXT, &quot;_ZN6Player4ChatEPKc&quot;);</span><br><span class="line">    orig(this, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Once, again, you compile then you run the client with DL_PRELOAD and when in the game, type “Michael” and you should be teleported to Michael Angelo.</p><h1 id="Move-faster-Jump-higher"><a href="#Move-faster-Jump-higher" class="headerlink" title="Move faster, Jump higher"></a>Move faster, Jump higher</h1><p>For this final exercise, we will change the capacity of our character to move faster on the fly. Instead of always editing the binary and restart the game, we will hook the library so that whenever we send a particular string in the chat, it will modify our movement speed.</p><p>In our previous blog post, we edited the sprint multiplier, however, here we want to change the default walking speed. For the, I simply search for “getspeed” in Hopper.</p><p>The function Player::GetWalkingSpeed() belongs to the class Player and returns a local variable of the instantiated object that calls the function. It’s a typical accessor method.</p><p>Unfortunately, I cannot simply get the value of a variable based on its name. The only thing I know is that the value for the walking speed is located at an offset of 736 (integer) bytes. Between that variable and the beginning of the objects are other variables and pointers, which would take too much time to entirely reverse. But there is no need to, the offset is sufficient. In our hook, we will simply edit the value located at this specific offset. For this, I will use an array as a “padding”:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Player &#123;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        char padding[736];</span><br><span class="line">        float speed;</span><br><span class="line">        void Chat(const char *text);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">void Player::Chat(const char *text)</span><br><span class="line">&#123;</span><br><span class="line">    </span><br><span class="line">    std::string str(text);</span><br><span class="line"></span><br><span class="line">    if (str.compare(&quot;speed up&quot;) == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        this-&gt;jumpspeed = this-&gt;jumpspeed * 1.5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Call orignal Player::Chat() function</span><br><span class="line">    orig_chat_f_type orig;</span><br><span class="line">    orig = (orig_chat_f_type) dlsym(RTLD_NEXT, &quot;_ZN6Player4ChatEPKc&quot;);</span><br><span class="line">    orig(this, text);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>We can see in Hopper that the jump speed and the jump hold time is located at an offset of 740 (int) and 744 (int) bytes, thus right after the walking speed. We then simply need to add the two additional variables:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Player &#123;</span><br><span class="line"></span><br><span class="line">    public:</span><br><span class="line">        char padding[736];</span><br><span class="line">        float speed;</span><br><span class="line">        float jumpspeed;</span><br><span class="line">        float jumphold;</span><br><span class="line">        void Chat(const char *text);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><p>And later access and modify them with:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">this-&gt;jumpspeed </span><br><span class="line">this-&gt;jumphold</span><br></pre></td></tr></table></figure></p><p>You can find the final <a href="https://github.com/Foxmole/PwnAdventure3/blob/master/hook.cc" target="_blank" rel="noopener">hook.cc</a> code in our <a href="https://github.com/Foxmole/PwnAdventure3" target="_blank" rel="noopener">GitHub page</a>.</p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
          <category> 转载 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hook </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在svn中使用文件/目录链接</title>
      <link href="/%E5%B7%A5%E5%85%B7/svn_externals/"/>
      <url>/%E5%B7%A5%E5%85%B7/svn_externals/</url>
      <content type="html"><![CDATA[<p>在日常开发中经常会遇到几个团队的代码中，有部分代码是公用的，比如我所在团队的前后端就是用同一份<code>proto</code>协议，如果每次修改都要向两边提交，且不说会不会漏，就两次提交已经是不能忍受了。其实<code>svn</code>本身就有一个类似外链的功能，可以满足这中场景。<br><a id="more"></a></p><p>目录属性<code>svn:externals</code>,就可以搞定上面的问题，步骤如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 首先进入要用来链接外部代码目录</span><br><span class="line">2. 创建一个文本文件，估且叫他path.txt吧，文件里包含若干行，每行就是一个svn链接</span><br><span class="line">3. 命令：svn propset svn:externals . -F path.txt</span><br><span class="line">4. 命令：svn ci . -m &quot;say sth.&quot;</span><br><span class="line">5. 命令：svn up</span><br></pre></td></tr></table></figure></p><p>上面的步骤3中，如果觉得先弄一个txt文件比较麻烦，可以换成下面这个命令，可以启动一个vim编辑</p><pre><code>svn propedit svn:externals . --editor-cmd=vim</code></pre>]]></content>
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> svn </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello World</title>
      <link href="/%E6%8A%80%E6%9C%AF/hello-world/"/>
      <url>/%E6%8A%80%E6%9C%AF/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      <categories>
          
          <category> 技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PS3 </tag>
            
            <tag> Games </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
